<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GeoRAW</title>
  <style>
    :root {
      --bg: #0f1624;
      --panel: #151e2e;
      --text: #e6eefc;
      --accent: #5eead4;
      --muted: #9ca3af;
      --danger: #ef4444;
      --error: #f97316;
      --warn: #fbbf24;
      --info: #38bdf8;
      --debug: #cbd5e1;
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
    }
    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(94,234,212,0.12), transparent 25%), var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: stretch;
      padding: 12px;
    }
    .shell {
      width: calc(100vw - 24px);
      min-height: calc(100vh - 24px);
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 30px 60px rgba(0,0,0,0.35);
      display: flex;
      flex-direction: column;
    }
    h1 {
      margin: 0 0 8px 0;
      font-weight: 700;
      letter-spacing: -0.5px;
    }
    .subtitle { margin: 0 0 20px 0; color: var(--muted); display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .title-row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .pill {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      font-weight: 600;
      font-size: 13px;
    }
    p.desc { margin: 0 0 20px 0; color: var(--muted); }
    .grid { display: grid; gap: 12px; }
    label { display: block; font-size: 14px; color: var(--muted); margin-bottom: 6px; }
    input[type="text"], input[type="number"], select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      outline: none;
      appearance: none;
    }
    select {
      background: rgba(17,24,39,0.9);
      border: 1px solid rgba(255,255,255,0.1);
      color: var(--text);
    }
    select option {
      background: #0f1624;
      color: #e6eefc;
    }
    select:focus, input[type="text"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(94,234,212,0.15);
    }
    input[type="checkbox"] { margin-right: 8px; }
    .row { display: grid; gap: 12px; grid-template-columns: repeat(auto-fit, minmax(200px,1fr)); }
    .tabs { display: flex; gap: 8px; margin: 8px 0 16px; }
    .tab-button {
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      font-weight: 700;
      cursor: pointer;
    }
    .tab-button.active {
      background: linear-gradient(135deg, #22d3ee, #5eead4);
      color: #0f1624;
      box-shadow: 0 10px 30px rgba(34,211,238,0.35);
      border-color: transparent;
    }
    .tab-panel { display: none; height: 100%; }
    .tab-panel.active { display: block; height: 100%; }
    .picker { display: flex; align-items: stretch; gap: 0; position: relative; }
    .picker input { border-radius: 10px 0 0 10px; border-right: 0; }
    .picker-buttons { display: flex; position: relative; }
    .picker-buttons button {
      border-radius: 0 10px 10px 0;
      margin-left: 0;
      padding: 10px 14px;
      min-width: 110px;
      background: rgba(255,255,255,0.08);
      color: var(--text);
      box-shadow: none;
      border-left: 1px solid rgba(255,255,255,0.12);
    }
    .picker-buttons button + button { border-radius: 0 10px 10px 0; }
    .picker-buttons button:hover { border-color: var(--accent); }
    .picker-menu {
      position: absolute;
      right: 0;
      top: calc(100% + 4px);
      background: #111827;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
      padding: 6px;
      display: none;
      z-index: 10;
      min-width: 160px;
    }
    .picker-menu button {
      width: 100%;
      text-align: left;
      background: transparent;
      color: var(--text);
      border-radius: 8px;
      padding: 10px 12px;
      box-shadow: none;
      border: 1px solid transparent;
    }
    .picker-menu button:hover { border-color: var(--accent); }
    select.level {
      font-weight: 600;
    }
    button {
      background: linear-gradient(135deg, #22d3ee, #5eead4);
      color: #0f1624;
      border: none;
      border-radius: 12px;
      padding: 12px 16px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(34,211,238,0.35);
    }
    button.secondary {
      background: rgba(255,255,255,0.08);
      color: var(--text);
      box-shadow: none;
    }
    .actions { display: flex; gap: 12px; flex-wrap: wrap; margin-top: 12px; }
    .status { margin-top: 16px; padding: 12px; background: rgba(255,255,255,0.04); border-radius: 12px; border: 1px solid rgba(255,255,255,0.08); font-size: 14px; display:none; }
    .progress {
      margin-top: 12px;
      width: 100%;
      height: 8px;
      background: rgba(255,255,255,0.08);
      border-radius: 999px;
      overflow: hidden;
      display: none;
    }
    .progress-bar {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, #22c55e, #4ade80);
      transition: width 0.3s ease;
    }
    .progress-bar.indeterminate {
      width: 40%;
      animation: indeterminate 1.1s linear infinite;
    }
    .progress-bar.complete {
      width: 100%;
      animation: none;
    }
    @keyframes indeterminate {
      0% { margin-left: -40%; }
      50% { margin-left: 30%; width: 60%; }
      100% { margin-left: 110%; }
    }
    .hidden { display: none !important; }
    .results {
      max-height: 280px;
      overflow: auto;
      display: none;
    }
    .result-group {
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      margin-bottom: 10px;
      background: rgba(255,255,255,0.02);
    }
    .result-group summary {
      list-style: none;
      cursor: pointer;
      padding: 10px 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 700;
      color: #e5e7eb;
    }
    .result-group summary::-webkit-details-marker { display: none; }
    .result-group summary::after {
      content: "â–¸";
      margin-left: auto;
      color: #9ca3af;
      transition: transform 0.2s ease;
    }
    .result-group[open] summary::after { transform: rotate(90deg); }
    .result-body { padding: 0 10px 10px 10px; }
    .result-row {
      padding: 10px;
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 10px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .result-info { display: flex; flex-direction: column; gap: 4px; min-width: 0; }
    .result-path { color: #e5e7eb; word-break: break-all; }
    .result-msg { color: #9ca3af; font-size: 13px; }
    .badge {
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 700;
      text-transform: uppercase;
      font-size: 12px;
      white-space: nowrap;
      border: 1px solid rgba(255,255,255,0.08);
      color: #0f1624;
    }
    .badges { display: flex; gap: 8px; align-items: center; }
    .badge.tag {
      opacity: 0.9;
    }
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    .modal {
      background: #0f1624;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 16px;
      width: min(900px, 90%);
      max-height: 80vh;
      box-shadow: 0 20px 50px rgba(0,0,0,0.45);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .modal header { display: flex; justify-content: space-between; align-items: center; }
    .modal pre {
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 12px;
      margin: 0;
      overflow: auto;
      max-height: 60vh;
      color: #e5e7eb;
      font-size: 13px;
      white-space: pre-wrap;
    }
    .modal-actions { display: flex; gap: 10px; justify-content: flex-end; flex-wrap: wrap; }
    .toast {
      position: fixed;
      right: 16px;
      bottom: 16px;
      background: rgba(15,22,36,0.95);
      color: #e5e7eb;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
      display: none;
      z-index: 200;
      font-size: 14px;
      min-width: 220px;
    }
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    .modal {
      background: #0f1624;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 16px;
      width: min(900px, 90%);
      max-height: 80vh;
      box-shadow: 0 20px 50px rgba(0,0,0,0.45);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .modal header { display: flex; justify-content: space-between; align-items: center; }
    .modal pre {
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 12px;
      margin: 0;
      overflow: auto;
      max-height: 60vh;
      color: #e5e7eb;
      font-size: 13px;
      white-space: pre-wrap;
    }
    .modal-actions { display: flex; gap: 10px; justify-content: flex-end; flex-wrap: wrap; }
    .muted { color: var(--muted); }
    .exif-grid {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 16px;
      align-items: stretch;
      height: 100%;
      min-height: 0;
    }
    @media (max-width: 980px) {
      .exif-grid { grid-template-columns: 1fr; }
    }
    .exif-left {
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 0;
    }
    .file-list {
      margin-top: 8px;
      flex: 1;
      min-height: 0;
      overflow: auto;
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      background: rgba(255,255,255,0.02);
    }
    .file-row {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.03);
      cursor: pointer;
      user-select: none;
    }
    .file-row:last-child { border-bottom: none; }
    .file-row:hover { background: rgba(94,234,212,0.08); }
    .file-row.active {
      background: rgba(94,234,212,0.12);
      border-left: 3px solid var(--accent);
      padding-left: 7px;
    }
    .file-icon { width: 20px; text-align: center; opacity: 0.85; }
    .file-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .file-row.dir .file-icon { color: var(--accent); }
    .exif-right { display: flex; flex-direction: column; gap: 10px; min-height: 0; }
    .exif-header { display:flex; align-items:center; justify-content: space-between; gap: 10px; flex-wrap: wrap; }
    .exif-path { font-weight: 700; word-break: break-all; }
    .exif-details-card {
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      background: rgba(255,255,255,0.02);
      padding: 14px;
      min-height: 320px;
      flex: 1;
      min-height: 0;
      overflow: auto;
    }
    .exif-group { margin-bottom: 12px; }
    .exif-group:last-child { margin-bottom: 0; }
    .exif-group summary {
      cursor: pointer;
      list-style: none;
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 700;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.6px;
      font-size: 12px;
      padding: 6px 0;
    }
    .exif-group summary::-webkit-details-marker { display: none; }
    .exif-group summary::after {
      content: "â–¸";
      margin-left: auto;
      color: #9ca3af;
      transition: transform 0.2s ease;
    }
    .exif-group[open] summary::after { transform: rotate(90deg); }
    .exif-row { display: grid; grid-template-columns: 170px 1fr; gap: 10px; padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.04); }
    @media (max-width: 640px) { .exif-row { grid-template-columns: 1fr; } }
    .exif-row:last-child { border-bottom: none; }
    .exif-label { color: var(--muted); font-size: 13px; display:flex; align-items:center; gap:6px; }
    .exif-value { color: var(--text); word-break: break-word; }
    .exif-hint { font-size: 13px; color: var(--muted); margin: 6px 0; }
    .pill.small { padding: 4px 8px; font-size: 12px; }
    .pill.small.xmp-badge { background: var(--accent); color: #0f1624; border-color: transparent; }
  </style>
</head>
<body>
  <div class="shell">
    <div class="title-row">
      <h1 style="margin:0;">GeoRAW</h1>
      <span id="versionTag" class="pill" style="display:none;"></span>
    </div>
    <div class="subtitle">
      <span>Geotag RAW photos with GPX or tag Canon HDR/Focus series into XMP sidecars.</span>
    </div>

    <div class="tabs">
      <button id="tabBtnGps" class="tab-button active" onclick="switchTab('gps')">GPS tagging</button>
      <button id="tabBtnSeries" class="tab-button" onclick="switchTab('series')">Series tagging</button>
      <button id="tabBtnExif" class="tab-button" onclick="switchTab('exif')">EXIF viewer</button>
    </div>

    <div id="tab-gps" class="tab-panel active">
      <div class="grid">
        <div class="row">
          <div>
            <label>GPX file</label>
            <div class="picker">
              <input id="gpxPath" type="text" placeholder="/path/track.gpx">
                <div class="picker-buttons">
                  <button class="secondary" onclick="pickGPX()">Browse</button>
                </div>
              </div>
            </div>
        </div>

        <div class="row">
          <div>
            <label>Photos path (file / folder / glob)</label>
            <div class="picker">
              <input id="inputPathGps" type="text" placeholder="/photos/*.CR3 or C:\path\one.cr3;C:\path\two.cr3">
              <div class="picker-buttons">
                <button id="photoBrowseBtn" class="secondary" onclick="togglePickerMenu(event, 'pickerMenu', 'photoBrowseBtn')">Browse</button>
                <div id="pickerMenu" class="picker-menu">
                  <button onclick="pickFiles('inputPathGps'); hidePickerMenu('pickerMenu')">Select filesâ€¦</button>
                  <button onclick="pickFolder('inputPathGps'); hidePickerMenu('pickerMenu')">Select folderâ€¦</button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="row">
          <div>
            <label>Log level</label>
            <select id="logLevelGps" class="level">
              <option value="fatal" data-color="var(--danger)" style="color: var(--danger);">fatal</option>
              <option value="error" data-color="var(--error)" style="color: var(--error);">error</option>
              <option value="warning" data-color="var(--warn)" style="color: var(--warn);">warning</option>
              <option value="info" data-color="var(--info)" style="color: var(--info);" selected>info</option>
              <option value="debug" data-color="var(--debug)" style="color: var(--debug);">debug</option>
              <option value="trace" data-color="var(--muted)" style="color: var(--muted);">trace</option>
            </select>
          </div>
          <div>
            <label>Time offset (e.g. +1h30m or -00:00:30)</label>
            <input id="timeOffset" type="text" value="0s" placeholder="+1h30m or -00:00:30">
          </div>
        </div>
        <div class="row">
          <div>
            <label><input id="recursiveGps" type="checkbox"> Scan subdirectories</label>
          </div>
          <div>
            <label><input id="autoOffset" type="checkbox" checked> Auto-detect offset</label>
          </div>
          <div>
            <label><input id="overwriteGps" type="checkbox"> Overwrite existing GPS</label>
          </div>
        </div>

        <div class="actions">
          <button id="runBtnGps" onclick="runProcess()">Run</button>
          <button id="stopBtnGps" class="secondary" style="display:none;" onclick="stopProcess()">Stop</button>
        </div>

        <div id="progress-gps" class="progress"><div class="progress-bar"></div></div>
        <div id="status-gps" class="status"></div>
        <div id="results-gps" class="status results"></div>
        <div id="resultsActions-gps" class="actions" style="display:none; margin-top:4px;">
          <label style="display:flex; align-items:center; gap:6px; font-size:13px; color:#9ca3af;">
            <input type="checkbox" id="showAll-gps" onchange="toggleShowAll('gps', this.checked)" />
            Show all
          </label>
          <button class="secondary" onclick="clearResults('gps')">Clear</button>
          <button class="secondary" onclick="showLog()">View log</button>
          <button class="secondary" onclick="openFolder()">Open folder</button>
        </div>
      </div>
    </div>

    <div id="tab-series" class="tab-panel">
      <div class="grid">
        <div class="row">
          <div>
            <label>Photos path (file / folder / glob)</label>
            <div class="picker">
              <input id="inputPathSeries" type="text" placeholder="/photos/*.CR3 or C:\path\one.cr3;C:\path\two.cr3">
              <div class="picker-buttons">
                <button id="photoBrowseBtnSeries" class="secondary" onclick="togglePickerMenu(event, 'pickerMenuSeries', 'photoBrowseBtnSeries')">Browse</button>
                <div id="pickerMenuSeries" class="picker-menu">
                  <button onclick="pickFiles('inputPathSeries'); hidePickerMenu('pickerMenuSeries')">Select filesâ€¦</button>
                  <button onclick="pickFolder('inputPathSeries'); hidePickerMenu('pickerMenuSeries')">Select folderâ€¦</button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="row">
          <div>
            <label>Log level</label>
            <select id="logLevelSeries" class="level">
              <option value="fatal" data-color="var(--danger)" style="color: var(--danger);">fatal</option>
              <option value="error" data-color="var(--error)" style="color: var(--error);">error</option>
              <option value="warning" data-color="var(--warn)" style="color: var(--warn);">warning</option>
              <option value="info" data-color="var(--info)" style="color: var(--info);" selected>info</option>
              <option value="debug" data-color="var(--debug)" style="color: var(--debug);">debug</option>
              <option value="trace" data-color="var(--muted)" style="color: var(--muted);">trace</option>
            </select>
          </div>
          <div>
            <label>Detection mode</label>
            <select id="modeSeries">
              <option value="auto">Auto (HDR/Focus)</option>
              <option value="hdr">Force HDR</option>
              <option value="focus">Force Focus</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div>
            <label>Series prefix (random 6 chars by default)</label>
            <div class="picker">
              <input id="prefixSeries" type="text" placeholder="ABC123">
              <div class="picker-buttons">
                <button class="secondary" onclick="seedSeriesPrefix(true)">Randomize</button>
              </div>
            </div>
          </div>
          <div>
            <label>Start index</label>
            <input id="startIndexSeries" type="number" value="1" min="1">
          </div>
        </div>

        <div class="row">
          <div>
            <label>HDR tag name</label>
            <input id="hdrTagSeries" type="text" value="hdr_mode">
          </div>
          <div>
            <label>Focus bracketing tag name</label>
            <input id="focusTagSeries" type="text" value="focus_br">
          </div>
        </div>

        <div class="row">
          <div>
            <label><input id="recursiveSeries" type="checkbox"> Scan subdirectories</label>
          </div>
          <div>
            <label><input id="overwriteSeries" type="checkbox"> Overwrite existing series tags</label>
          </div>
        </div>

        <div class="actions">
          <button id="runSeriesBtn" onclick="runSeries()">Run</button>
          <button id="stopSeriesBtn" class="secondary" style="display:none;" onclick="stopProcess()">Stop</button>
        </div>

        <div id="progress-series" class="progress"><div class="progress-bar"></div></div>
        <div id="status-series" class="status"></div>
        <div id="results-series" class="status results"></div>
        <div id="resultsActions-series" class="actions" style="display:none; margin-top:4px;">
          <label style="display:flex; align-items:center; gap:6px; font-size:13px; color:#9ca3af;">
            <input type="checkbox" id="showAll-series" onchange="toggleShowAll('series', this.checked)" />
            Show all
          </label>
          <button class="secondary" onclick="clearResults('series')">Clear</button>
          <button class="secondary" onclick="showLog()">View log</button>
          <button class="secondary" onclick="openFolder()">Open folder</button>
        </div>
      </div>
    </div>

    <div id="tab-exif" class="tab-panel">
      <div class="exif-grid">
        <div class="exif-left">
          <div class="row">
            <div>
              <label>Root folder</label>
              <div class="picker">
                <input id="exifRootPath" type="text" placeholder="/photos">
                <div class="picker-buttons">
                  <button class="secondary" onclick="pickExifFolder()">Browse</button>
                </div>
              </div>
            </div>
          </div>
          <div class="row" style="margin-top:4px;">
            <label style="display:flex; align-items:center; gap:8px; font-size:13px; color:var(--muted);">
              <input id="exifIncludeXmp" type="checkbox" style="margin:0;" />
              Include XMP
            </label>
          </div>
          <div class="row" style="margin-top:6px;">
            <div>
              <input id="exifSearch" type="text" placeholder="Search files..." aria-label="Search files">
            </div>
          </div>
          <div id="exifTreeNotice" class="exif-hint muted"></div>
          <div id="exifList" class="file-list"></div>
          <div class="exif-hint">Double-click a folder to open it. Nested folders are listed inline.</div>
        </div>
        <div class="exif-right">
          <div class="row" style="margin-bottom:6px;">
            <div>
              <input id="exifMetaSearch" type="text" placeholder="Search metadata..." aria-label="Search metadata">
            </div>
          </div>
          <div class="exif-header">
            <div class="exif-path" id="exifSelectedPath">Select a file to inspect EXIF</div>
            <span id="exifTruncated" class="pill small" style="display:none;">Limited list</span>
          </div>
          <div id="status-exif" class="status"></div>
          <div id="exifDetails" class="exif-details-card">
            <div class="muted">Pick a file on the left to see its metadata.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="logModal" class="modal-backdrop">
    <div class="modal">
      <header>
        <h3 style="margin:0;">Log</h3>
      </header>
      <pre id="logContent">Loading...</pre>
      <div class="modal-actions">
        <button class="secondary" onclick="copyLog()">Copy</button>
        <button class="secondary" onclick="downloadLog()">Download</button>
        <button onclick="hideLog()">Close</button>
      </div>
    </div>
  </div>
  <div id="toast" class="toast"></div>

  <script src="/wails/runtime.js"></script>
  <script>
    function fitWindowToContent() {
      if (!(window.runtime && window.runtime.WindowSetSize)) return;

      const doc = document.documentElement;
      const body = document.body;

      const contentW = Math.max(
        doc.scrollWidth,
        doc.clientWidth,
        body ? body.scrollWidth : 0,
        body ? body.clientWidth : 0
      );
      const contentH = Math.max(
        doc.scrollHeight,
        doc.clientHeight,
        body ? body.scrollHeight : 0,
        body ? body.clientHeight : 0
      );

      const chromeW = Math.max(0, window.outerWidth - window.innerWidth);
      const chromeH = Math.max(0, window.outerHeight - window.innerHeight);

      const minW = 900, minH = 700;
      const maxW = Math.max(minW, (window.screen?.availWidth || contentW) - 20);
      const maxH = Math.max(minH, (window.screen?.availHeight || contentH) - 60);

      const targetWidth = Math.min(Math.max(contentW + chromeW, minW), maxW);
      const targetHeight = Math.min(Math.max(contentH + chromeH, minH), maxH);

      window.runtime.WindowSetSize(targetWidth, targetHeight);
      if (window.runtime.WindowCenter) window.runtime.WindowCenter();
    }

    window.addEventListener('load', () => {
      applyLogLevelColor('logLevelGps');
      applyLogLevelColor('logLevelSeries');
      seedSeriesPrefix(true);
      showVersionTag();
      subscribeToProgress();
      initExifTab();
      document.addEventListener('click', (e) => {
        ['pickerMenu', 'pickerMenuSeries'].forEach(id => {
          const menu = document.getElementById(id);
          const btnId = id === 'pickerMenu' ? 'photoBrowseBtn' : 'photoBrowseBtnSeries';
          const btn = document.getElementById(btnId);
          if (!menu || !btn) return;
          if (menu.contains(e.target) || btn.contains(e.target)) return;
          hidePickerMenu(id);
        });
      });
    });

    function subscribeToProgress() {
      if (!(window.runtime && window.runtime.EventsOn)) return;
      window.runtime.EventsOn('progress', handleProgressEvent);
    }

    const tabButtons = { gps: 'tabBtnGps', series: 'tabBtnSeries', exif: 'tabBtnExif' };

    function switchTab(tab) {
      Object.keys(tabButtons).forEach(t => {
        const panel = document.getElementById(`tab-${t}`);
        if (panel) {
          panel.classList.toggle('active', t === tab);
          panel.style.display = t === tab ? 'block' : 'none';
        }
        const btn = document.getElementById(tabButtons[t]);
        if (btn) btn.classList.toggle('active', t === tab);
      });
      if (tab === 'exif') {
        ensureExifLoaded();
      }
      fitWindowToContent();
    }

    function getBackend() {
      if (window.backend) return window.backend;
      if (window.go && window.go.gui && window.go.gui.Backend) {
        window.backend = window.go.gui.Backend;
        return window.backend;
      }
      if (window.go && window.go.main && window.go.main.Backend) {
        window.backend = window.go.main.Backend;
        return window.backend;
      }
      throw new Error("Backend is not ready yet");
    }

    let isRunning = false;
    let currentContext = null;
    let cachedLog = "";
    let lastFolderPath = "";
    let toastTimer = null;
    const showAllFlags = { gps: false, series: false };
    const lastSummary = { gps: null, series: null };
    const EXIF_LIST_LIMIT = 5000;
    const exifState = {
      root: "",
      tree: [],
      filtered: [],
      selected: "",
      truncated: false,
      includeXmp: true,
      lastDetails: null,
      metaQuery: "",
    };
    let exifFilterTimer = null;
    let exifMetaTimer = null;

    function setRunning(context, running) {
      isRunning = running;
      currentContext = running ? context : null;
      const runGps = document.getElementById('runBtnGps');
      const runSeries = document.getElementById('runSeriesBtn');
      if (runGps) runGps.disabled = running;
      if (runSeries) runSeries.disabled = running;

      const stopGps = document.getElementById('stopBtnGps');
      const stopSeries = document.getElementById('stopSeriesBtn');
      if (stopGps) stopGps.style.display = running && context === 'gps' ? 'inline-flex' : 'none';
      if (stopSeries) stopSeries.style.display = running && context === 'series' ? 'inline-flex' : 'none';

      const progress = document.getElementById(`progress-${context}`);
      const bar = progress ? progress.querySelector('.progress-bar') : null;
      if (progress && bar) {
        progress.style.display = running ? 'block' : 'none';
        bar.classList.remove('complete', 'indeterminate');
        bar.style.marginLeft = '0';
        if (running) {
          bar.style.width = '0%';
        }
      }
    }

    function handleProgressEvent(payload) {
      const { context, current, total } = payload || {};
      if (!context) return;
      updateProgressBar(context, current, total);
    }

    function updateProgressBar(context, current, total) {
      const progress = document.getElementById(`progress-${context}`);
      const bar = progress ? progress.querySelector('.progress-bar') : null;
      if (!progress || !bar || !Number.isFinite(total) || total <= 0) return;
      const pct = Math.max(0, Math.min(100, Math.round((Number(current) / Number(total)) * 100)));
      progress.style.display = 'block';
      bar.classList.remove('indeterminate', 'complete');
      bar.style.marginLeft = '0';
      bar.style.width = `${pct}%`;
    }

    async function pickGPX() {
      try {
        const result = await getBackend().PickGPX();
        if (result) document.getElementById('gpxPath').value = result;
      } catch (e) { setStatus('gps', e.message, true); }
    }

    async function pickFolder(targetId) {
      try {
        const result = await getBackend().PickFolder();
        if (result) document.getElementById(targetId).value = result;
      } catch (e) { setStatus(currentContext || 'gps', e.message, true); }
    }
    async function pickFiles(targetId) {
      try {
        const result = await getBackend().PickFiles();
        if (result && result.length) {
          document.getElementById(targetId).value = result.join(';');
        }
      } catch (e) { setStatus(currentContext || 'gps', e.message, true); }
    }

    function togglePickerMenu(e, id) {
      e.stopPropagation();
      const menu = document.getElementById(id);
      if (!menu) return;
      menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
    }
    function hidePickerMenu(id) {
      const menu = document.getElementById(id);
      if (menu) menu.style.display = 'none';
    }

    function initExifTab() {
      const list = document.getElementById('exifList');
      if (list) {
        list.addEventListener('click', handleExifClick);
        list.addEventListener('dblclick', handleExifDblClick);
        list.innerHTML = "<div class=\"file-row\"><span class=\"file-name\" style=\"color:var(--muted);\">Select a folder to load files.</span></div>";
      }
      const search = document.getElementById('exifSearch');
      if (search) {
        search.addEventListener('input', () => {
          if (exifFilterTimer) clearTimeout(exifFilterTimer);
          exifFilterTimer = setTimeout(() => applyExifFilter(true), 140);
        });
      }
      const includeXmp = document.getElementById('exifIncludeXmp');
      if (includeXmp) {
        includeXmp.checked = true;
        exifState.includeXmp = true;
        includeXmp.addEventListener('change', () => {
          exifState.includeXmp = includeXmp.checked;
          if (exifState.selected) {
            loadExifDetails(exifState.selected);
          }
        });
      }
      const metaSearch = document.getElementById('exifMetaSearch');
      if (metaSearch) {
        metaSearch.addEventListener('input', () => {
          if (exifMetaTimer) clearTimeout(exifMetaTimer);
          exifMetaTimer = setTimeout(() => {
            exifState.metaQuery = metaSearch.value.trim();
            if (exifState.lastDetails) {
              renderExifDetails(exifState.lastDetails);
            }
          }, 120);
        });
      }
    }

    function ensureExifLoaded() {
      const input = document.getElementById('exifRootPath');
      if (!exifState.root && input && input.value.trim()) {
        exifState.root = input.value.trim();
      }
      if (!exifState.root && lastFolderPath) {
        exifState.root = lastFolderPath;
        if (input) input.value = lastFolderPath;
      }
      if (exifState.tree.length === 0 && exifState.root) {
        refreshExifTree();
      }
    }

    async function pickExifFolder() {
      try {
        const result = await getBackend().PickFolder();
        if (result) {
          document.getElementById('exifRootPath').value = result;
          exifState.root = result;
          exifState.selected = "";
          await refreshExifTree();
        }
      } catch (e) { setStatus('exif', e.message, true); }
    }

    function setExifLoading(loading, message = "") {
      const list = document.getElementById('exifList');
      if (loading && list) {
        list.innerHTML = `<div class="file-row"><span class="file-name" style="color:var(--muted);">${message || 'Loading...'}</span></div>`;
      }
    }

    async function refreshExifTree() {
      const input = document.getElementById('exifRootPath');
      const rawPath = input ? input.value.trim() : "";
      const target = rawPath || exifState.root || lastFolderPath;
      if (!target) {
        setStatus('exif', "Select a folder to browse", true);
        return;
      }
      setStatus('exif', "", false);
      setExifLoading(true, "Loading files...");
      try {
        const res = await getBackend().ListExifTree(target);
        exifState.root = (res && res.root) || target;
        exifState.tree = (res && Array.isArray(res.children)) ? res.children : [];
        exifState.truncated = !!(res && res.truncated);
        exifState.selected = "";
        exifState.lastDetails = null;
        if (input) input.value = exifState.root;
        setExifSelectedPath("Select a file to inspect EXIF");
        setExifDetailsPlaceholder("Pick a file on the left to see its metadata.");
        applyExifFilter(true);
        fitWindowToContent();
      } catch (e) {
        setStatus('exif', e.message || String(e), true);
      } finally {
        setExifLoading(false);
      }
    }

    function applyExifFilter(renderList = false) {
      const search = document.getElementById('exifSearch');
      const query = search ? search.value.trim() : "";
      exifState.filtered = filterFileTree(exifState.tree, query);
      if (renderList) drawExifList(exifState.filtered);
    }

    function filterFileTree(nodes, query) {
      const matcher = makeWildcardMatcher(query);
      const walk = (items) => {
        const next = [];
        (items || []).forEach(item => {
          const children = item.children ? walk(item.children) : [];
          const matchSelf = matcher(item.name);
          if (matchSelf || children.length) {
            next.push({
              name: item.name,
              path: item.path,
              isDir: !!item.isDir,
              children,
            });
          }
        });
        return next;
      };
      return walk(nodes || []);
    }

    function makeWildcardMatcher(query) {
      if (!query) return () => true;
      let pattern = query;
      if (!pattern.includes("*")) {
        pattern = `*${pattern}*`;
      }
      const escaped = pattern.replace(/[.+?^${}()|[\]\\]/g, "\\$&").replace(/\*/g, ".*");
      const re = new RegExp(`^${escaped}$`, "i");
      return (text) => re.test(text || "");
    }

    function filterExifDetails(details, query) {
      if (!details || !Array.isArray(details.fields)) return details;
      if (!query) return details;
      const text = query.toLowerCase();
      const contains = (val) => (val || "").toString().toLowerCase().includes(text);
      const filtered = details.fields.filter(f => contains(f.label) || contains(f.value));
      return { ...details, fields: filtered };
    }

    function drawExifList(nodes) {
      const list = document.getElementById('exifList');
      if (!list) return;
      list.innerHTML = "";
      const search = document.getElementById('exifSearch');
      const query = search ? search.value.trim() : "";
      if (!nodes || nodes.length === 0) {
        const msg = query ? "No files match the filter." : "No supported files found in this folder.";
        list.innerHTML = `<div class="file-row"><span class="file-name" style="color:var(--muted);">${msg}</span></div>`;
        updateExifNotice(true);
        return;
      }
      const frag = document.createDocumentFragment();
      const renderLevel = (items, depth) => {
        items.forEach(item => {
          const row = document.createElement('div');
          row.className = `file-row ${item.isDir ? 'dir' : 'file'}`;
          if (!item.isDir && item.path === exifState.selected) {
            row.classList.add('active');
          }
          row.dataset.path = item.path;
          row.dataset.isdir = item.isDir ? "1" : "0";
          row.style.paddingLeft = `${depth * 14 + 8}px`;

          const icon = document.createElement('span');
          icon.className = 'file-icon';
          icon.textContent = item.isDir ? "ðŸ“" : "ðŸ“·";
          const name = document.createElement('span');
          name.className = 'file-name';
          name.textContent = item.name;
          row.appendChild(icon);
          row.appendChild(name);
          frag.appendChild(row);
          if (item.children && item.children.length) {
            renderLevel(item.children, depth + 1);
          }
        });
      };
      renderLevel(nodes, 0);
      list.appendChild(frag);
      updateExifNotice(false);
    }

    function updateExifNotice(noMatches) {
      const notice = document.getElementById('exifTreeNotice');
      const pill = document.getElementById('exifTruncated');
      if (pill) {
        pill.style.display = exifState.truncated ? 'inline-flex' : 'none';
      }
      if (!notice) return;
      const parts = [];
      if (exifState.truncated) {
        parts.push(`Showing first ${EXIF_LIST_LIMIT} items. Use search to narrow results.`);
      }
      if (noMatches) {
        parts.push("Nothing matches the current filter.");
      }
      notice.textContent = parts.join(" ");
      notice.style.display = parts.length ? 'block' : 'none';
    }

    function setActiveFileRow(path) {
      const list = document.getElementById('exifList');
      if (!list) return;
      const rows = list.querySelectorAll('.file-row');
      rows.forEach(row => {
        const isFile = row.dataset.isdir !== "1";
        row.classList.toggle('active', isFile && path && row.dataset.path === path);
      });
    }

    function handleExifClick(e) {
      const row = e.target.closest('.file-row');
      if (!row || !row.dataset.path) return;
      const isDir = row.dataset.isdir === "1";
      const path = row.dataset.path;
      if (isDir) {
        exifState.selected = "";
        setActiveFileRow(null);
        setExifSelectedPath(`Folder: ${path} (double-click to open)`);
        return;
      }
      exifState.selected = path;
      setActiveFileRow(path);
      loadExifDetails(path);
    }

    function handleExifDblClick(e) {
      const row = e.target.closest('.file-row');
      if (!row || !row.dataset.path) return;
      const isDir = row.dataset.isdir === "1";
      const path = row.dataset.path;
      if (isDir) {
        const input = document.getElementById('exifRootPath');
        if (input) input.value = path;
        exifState.root = path;
        exifState.selected = "";
        refreshExifTree();
        return;
      }
      exifState.selected = path;
      setActiveFileRow(path);
      loadExifDetails(path);
    }

    function setExifSelectedPath(text) {
      const el = document.getElementById('exifSelectedPath');
      if (el) {
        el.textContent = text || "Select a file to inspect EXIF";
      }
    }

    function setExifDetailsPlaceholder(message) {
      const container = document.getElementById('exifDetails');
      if (container) {
        container.innerHTML = `<div class="muted">${message}</div>`;
      }
    }

    async function loadExifDetails(path) {
      if (!path) return;
      setStatus('exif', "", false);
      setExifDetailsPlaceholder("Loading EXIFâ€¦");
      setExifSelectedPath(path);
      try {
        const res = await getBackend().ReadExif(path, !!exifState.includeXmp);
        exifState.lastDetails = res;
        exifState.metaQuery = "";
        const metaInput = document.getElementById('exifMetaSearch');
        if (metaInput) metaInput.value = "";
        renderExifDetails(res);
      } catch (e) {
        setStatus('exif', e.message || String(e), true);
        setExifDetailsPlaceholder("Failed to read EXIF.");
      }
    }

    function renderExifDetails(data) {
      const container = document.getElementById('exifDetails');
      if (!container) return;
      container.innerHTML = "";
      if (exifState.metaQuery) {
        const filtered = filterExifDetails(data, exifState.metaQuery);
        if (filtered && Array.isArray(filtered.fields)) {
          data = filtered;
        }
      }
      const fields = data && Array.isArray(data.fields) ? data.fields : [];
      if (!fields.length) {
        setExifDetailsPlaceholder("No EXIF data found for this file.");
        return;
      }
      const groups = {};
      fields.forEach(f => {
        const key = f.group || "Details";
        if (!groups[key]) groups[key] = [];
        groups[key].push(f);
      });

      Object.keys(groups).sort().forEach((groupName, idx) => {
        const detail = document.createElement('details');
        detail.className = 'exif-group';
        detail.open = idx === 0;

        const summary = document.createElement('summary');
        summary.textContent = `${groupName} (${groups[groupName].length})`;
        detail.appendChild(summary);

        groups[groupName].forEach(item => {
          const row = document.createElement('div');
          row.className = 'exif-row';
          const label = document.createElement('div');
          label.className = 'exif-label';
          const isXmp = typeof item.label === 'string' && /\sxmp$/i.test(item.label);
          const cleanLabel = isXmp ? item.label.replace(/\s*xmp$/i, "") : item.label;
          label.textContent = cleanLabel;
          if (isXmp) {
            const badge = document.createElement('span');
            badge.className = 'pill small xmp-badge';
            badge.textContent = 'XMP';
            label.appendChild(badge);
          }
          const value = document.createElement('div');
          value.className = 'exif-value';
          value.textContent = item.value;
          row.appendChild(label);
          row.appendChild(value);
          detail.appendChild(row);
        });

        container.appendChild(detail);
      });
    }

    async function runProcess() {
      const ctx = 'gps';
      setStatus(ctx, "Running...", false);
      clearResults(ctx);
      setRunning(ctx, true);
      resetProgress(ctx, false);
      await getBackend().ClearLogs();
      lastFolderPath = "";
      const req = {
        gpxPath: document.getElementById('gpxPath').value,
        inputPath: document.getElementById('inputPathGps').value,
        recursive: document.getElementById('recursiveGps').checked,
        logLevel: document.getElementById('logLevelGps').value,
        timeOffset: (document.getElementById('timeOffset').value || "0s").trim(),
        autoOffset: document.getElementById('autoOffset').checked,
        overwrite: document.getElementById('overwriteGps').checked,
      };
      try {
        const res = await getBackend().Process(req);
        renderResults(ctx, res);
      } catch (err) {
        setStatus(ctx, err.message || String(err), true);
      } finally {
        setRunning(ctx, false);
        markProgressComplete(ctx);
      }
    }

    async function runSeries() {
      const ctx = 'series';
      setStatus(ctx, "Running...", false);
      clearResults(ctx);
      setRunning(ctx, true);
      resetProgress(ctx, false);
      await getBackend().ClearLogs();
      lastFolderPath = "";
      let startIndex = parseInt(document.getElementById('startIndexSeries').value || "1", 10);
      if (isNaN(startIndex) || startIndex < 1) {
        startIndex = 1;
      }
      const req = {
        inputPath: document.getElementById('inputPathSeries').value,
        recursive: document.getElementById('recursiveSeries').checked,
        logLevel: document.getElementById('logLevelSeries').value,
        overwrite: document.getElementById('overwriteSeries').checked,
        mode: document.getElementById('modeSeries').value,
        prefix: document.getElementById('prefixSeries').value,
        startIndex,
        hdrTag: document.getElementById('hdrTagSeries').value,
        focusTag: document.getElementById('focusTagSeries').value,
      };
      try {
        const res = await getBackend().ProcessSeries(req);
        renderResults(ctx, res);
      } catch (err) {
        setStatus(ctx, err.message || String(err), true);
      } finally {
        setRunning(ctx, false);
        markProgressComplete(ctx);
      }
    }

    async function stopProcess() {
      try {
        await getBackend().Cancel();
        if (currentContext) {
          setStatus(currentContext, "Cancelling...", false);
        }
      } catch (err) {
        setStatus(currentContext || 'gps', err.message || String(err), true);
      }
    }

    function setStatus(context, msg, isError) {
      const el = document.getElementById(`status-${context}`);
      if (!el) return;
      if (!msg) {
        el.style.display = 'none';
        return;
      }
      el.textContent = msg;
      el.style.color = isError ? "#fca5a5" : "#e6eefc";
      el.style.display = 'block';
    }

    function renderResults(context, summary) {
      if (!summary) return;
      lastSummary[context] = summary;
      const hasErrors = (summary.failed > 0) || (summary.meta_errors > 0);
      if (hasErrors) {
        const status = `Finished with issues. failed=${summary.failed} meta_errors=${summary.meta_errors}`;
        setStatus(context, status, true);
        showToast("Finished with issues", "warn");
      } else {
        setStatus(context, "", false);
        showToast("Finished", "info");
      }

      const filtered = (summary.files || []).filter(item => shouldShowStatus(context, item.status));

      const seriesGroups = new Map();
      const skippedGroup = [];
      const ungrouped = [];

      filtered.forEach(item => {
        const message = item.message || "";
        const tagMatch = message.match(/^([a-zA-Z0-9_]+)\s+\[([^\]]+)\]$/);
        const tagInfo = tagMatch ? { type: tagMatch[1], id: tagMatch[2] } : null;

        if (item.status === 'skipped') {
          skippedGroup.push({ item, tagInfo });
          return;
        }
        if (tagInfo && tagInfo.id) {
          const key = tagInfo.id;
          if (!seriesGroups.has(key)) {
            seriesGroups.set(key, { tag: tagInfo.type, id: tagInfo.id, items: [] });
          }
          seriesGroups.get(key).items.push({ item, tagInfo });
        } else {
          ungrouped.push({ item, tagInfo });
        }
      });

      const colors = {
        processed: { bg: "#34d399", fg: "#0f172a" },
        unchanged: { bg: "#a5b4fc", fg: "#0f172a" },
        skipped: { bg: "#9ca3af", fg: "#0f172a" },
        out_of_track: { bg: "#fbbf24", fg: "#0f172a" },
        meta_error: { bg: "#f97316", fg: "#0f172a" },
        failed: { bg: "#f87171", fg: "#0f172a" },
      };
      const tagColors = {
        hdr_mode: { bg: "#38bdf8", fg: "#0f172a" },
        focus_br: { bg: "#f59e0b", fg: "#0f172a" },
      };

      const renderTagBadge = (tagType) => {
        if (!tagType) return "";
        const tagPalette = tagColors[tagType] || { bg: "#cbd5e1", fg: "#0f172a" };
        return `<span class="badge tag" style="background:${tagPalette.bg};color:${tagPalette.fg};">${tagType}</span>`;
      };

      const renderRow = ({ item, tagInfo }) => {
        const palette = colors[item.status] || { bg: "#e5e7eb", fg: "#0f172a" };
        const idLine = tagInfo ? `id: [${tagInfo.id}]` : (item.message || "");

        return `<div class="result-row">
          <div class="result-info">
            <span class="result-path">${item.path}</span>
            ${idLine ? `<span class="result-msg">${idLine}</span>` : ""}
          </div>
          <div class="badges">
            ${tagInfo ? renderTagBadge(tagInfo.type) : ""}
            <span class="badge" style="background:${palette.bg};color:${palette.fg};">${item.status}</span>
          </div>
        </div>`;
      };

      const renderGroup = (title, items, tagType) => {
        const rows = items.map(renderRow).join("");
        return `<details class="result-group">
          <summary>${tagType ? renderTagBadge(tagType) + " " : ""}${title}</summary>
          <div class="result-body">${rows}</div>
        </details>`;
      };

      let html = "";
      Array.from(seriesGroups.values())
        .sort((a, b) => a.id.localeCompare(b.id))
        .forEach(group => {
          const label = `Series ${group.id} (${group.items.length})`;
          html += renderGroup(label, group.items, group.tag);
        });

      if (skippedGroup.length) {
        const label = `Skipped (${skippedGroup.length})`;
        html += renderGroup(label, skippedGroup);
      }

      if (ungrouped.length) {
        html += ungrouped.map(renderRow).join("");
      }
      const resultsEl = document.getElementById(`results-${context}`);
      if (resultsEl) {
        const fallbackMsg = filtered.length === 0 && (summary.files && summary.files.length) ?
          "<div style='color:#9ca3af;'>No files match the filter. Turn on \"Show all\" to include skipped ones.</div>" :
          "<div style='color:#9ca3af;'>No files processed.</div>";
        resultsEl.innerHTML = html || fallbackMsg;
        resultsEl.style.display = summary.files && summary.files.length ? 'block' : 'none';
      }
      const actions = document.getElementById(`resultsActions-${context}`);
      if (actions) {
        actions.style.display = summary.files && summary.files.length ? 'flex' : 'none';
      }
      if (summary.files && summary.files.length) {
        const chosen = (filtered[0]?.path ? filtered[0].path : summary.files[0].path) || "";
        const firstPath = chosen || "";
        lastFolderPath = extractDir(firstPath);
      }
    }

    function applyLogLevelColor(id) {
      const select = document.getElementById(id);
      if (!select) return;
      const opt = select.options[select.selectedIndex];
      const color = opt?.getAttribute('data-color') || 'var(--text)';
      select.style.color = color;
    }
    document.getElementById('logLevelGps').addEventListener('change', () => applyLogLevelColor('logLevelGps'));
    document.getElementById('logLevelSeries').addEventListener('change', () => applyLogLevelColor('logLevelSeries'));

    function markProgressComplete(context) {
      const progress = document.getElementById(`progress-${context}`);
      const bar = progress ? progress.querySelector('.progress-bar') : null;
      if (!progress || !bar) return;
      progress.style.display = 'block';
      bar.classList.remove('indeterminate');
      bar.classList.add('complete');
      bar.style.marginLeft = '0';
      bar.style.width = '100%';
    }

    function resetProgress(context, hide = true) {
      const progress = document.getElementById(`progress-${context}`);
      const bar = progress ? progress.querySelector('.progress-bar') : null;
      if (!progress || !bar) return;
      bar.classList.remove('indeterminate', 'complete');
      bar.style.marginLeft = '0';
      bar.style.width = '0%';
      if (hide) progress.style.display = 'none';
    }

    function shouldShowStatus(context, status) {
      if (showAllFlags[context]) return true;
      const visible = new Set(['processed', 'failed', 'meta_error', 'out_of_track']);
      return visible.has(status);
    }

    function toggleShowAll(context, checked) {
      showAllFlags[context] = !!checked;
      const summary = lastSummary[context];
      if (summary) {
        renderResults(context, summary);
      }
    }

    function clearResults(context) {
      const resultsEl = document.getElementById(`results-${context}`);
      if (resultsEl) {
        resultsEl.innerHTML = "";
        resultsEl.style.display = 'none';
      }
      const actions = document.getElementById(`resultsActions-${context}`);
      if (actions) actions.style.display = 'none';
      showAllFlags[context] = false;
      lastSummary[context] = null;
      const checkbox = document.getElementById(`showAll-${context}`);
      if (checkbox) checkbox.checked = false;
      setStatus(context, "", false);
      resetProgress(context);
      cachedLog = "";
      hideLog();
      lastFolderPath = "";
    }

    document.getElementById('gpxPath').addEventListener('input', () => resetProgress('gps'));
    document.getElementById('inputPathGps').addEventListener('input', () => resetProgress('gps'));
    document.getElementById('inputPathSeries').addEventListener('input', () => resetProgress('series'));

    function extractDir(path) {
      if (!path) return "";
      const normalized = path.replace(/\\/g, "/");
      const idx = normalized.lastIndexOf("/");
      if (idx === -1) return path;
      return normalized.slice(0, idx);
    }

    async function openFolder() {
      if (!lastFolderPath) {
        showToast("No folder to open", "warn");
        return;
      }
      try {
        await getBackend().OpenFolder(lastFolderPath);
        showToast("Opening folder");
      } catch (e) {
        showToast(e.message || "Failed to open folder", "error");
      }
    }
    async function showLog() {
      try {
        const log = await getBackend().GetLogs();
        cachedLog = log || "";
        document.getElementById('logContent').textContent = cachedLog || "Log is empty.";
        document.getElementById('logModal').style.display = 'flex';
      } catch (e) {
        setStatus(currentContext || 'gps', e.message, true);
      }
    }
    function hideLog() {
      document.getElementById('logModal').style.display = 'none';
    }
    async function downloadLog() {
      try {
        const path = await getBackend().SaveLog();
        if (path) {
          showToast("Log saved");
        }
      } catch (e) {
        showToast(e.message || "Failed to save log", "error");
      }
    }
    async function copyLog() {
      const data = cachedLog || document.getElementById('logContent').textContent || "";
      try {
        await navigator.clipboard.writeText(data);
        showToast("Log copied to clipboard");
      } catch (e) {
        showToast("Failed to copy log", "error");
      }
    }

    function showToast(msg, kind = "info") {
      const toast = document.getElementById('toast');
      if (!toast) return;
      toast.textContent = msg;
      const colorMap = { info: "#38bdf8", warn: "#fbbf24", error: "#f97316" };
      toast.style.borderColor = colorMap[kind] || "rgba(255,255,255,0.12)";
      toast.style.display = 'block';
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(() => { toast.style.display = 'none'; }, 2500);
    }

    function randomPrefix(len = 6) {
      const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      let out = "";
      for (let i = 0; i < len; i++) {
        out += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
      }
      return out;
    }
    function seedSeriesPrefix(force = false) {
      const field = document.getElementById('prefixSeries');
      if (!field) return;
      if (force || !field.value.trim()) {
        field.value = randomPrefix(6);
      }
    }
    async function showVersionTag() {
      try {
        const v = await getBackend().Version();
        const el = document.getElementById('versionTag');
        if (el && v) {
          el.textContent = v.startsWith('v') ? v : `v${v}`;
          el.style.display = 'inline-flex';
        }
      } catch (_) {
        // ignore
      }
    }
  </script>
</body>
</html>
